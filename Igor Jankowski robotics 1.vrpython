{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vexcode_vr import *\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\nlocation = Location(\"location\", 9)\n#endregion VEXcode Generated Robot Configuration\n\nSTEP = 250          # distance moved each step (one tile)\nOPEN = 180          # distance threshold for detecting open paths\nKEY = 50            # grid rounding size for mapping positions\n\nrightDist = 0\nfrontDist = 0\nleftDist = 0\n\nheading = 0         # robot direction: 0=N, 1=E, 2=S, 3=W\nmoved_steps = 0     # counts how many steps have been taken\n\nedges = {}          # graph connections between maze tiles\nroute = []          # recorded movement history (fallback)\n\nfinishk = None      # finish tile key\n\ndef turnR():\n    # turn right and update heading\n    global heading\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    heading = (heading + 1) % 4\n\ndef turnL():\n    # turn left and update heading\n    global heading\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n    heading = (heading - 1) % 4\n\ndef turn180():\n    # turn around and update heading\n    global heading\n    drivetrain.turn_for(RIGHT, 180, DEGREES)\n    heading = (heading + 2) % 4\n\ndef curkey():\n    # convert robot position into a grid key string\n    x = location.position(X, MM)\n    y = location.position(Y, MM)\n    kx = int(round(x / KEY))\n    ky = int(round(y / KEY))\n    return str(kx) + \":\" + str(ky)\n\ndef key_xy(k):\n    # split a key string back into coordinates\n    p = k.split(\":\")\n    return int(p[0]), int(p[1])\n\ndef add_edge(a, b):\n    # store a two-way connection in the maze graph\n    if a not in edges: edges[a] = set()\n    if b not in edges: edges[b] = set()\n    edges[a].add(b)\n    edges[b].add(a)\n\ndef scan():\n    # measure distances right, front, left\n    global rightDist, frontDist, leftDist\n    turnR()\n    rightDist = front_distance.get_distance(MM)\n    turnL()\n    frontDist = front_distance.get_distance(MM)\n    turnL()\n    leftDist = front_distance.get_distance(MM)\n    turnR()\n\ndef step_dir_pref():\n    # choose direction using right-hand wall following\n    scan()\n    if rightDist > OPEN: return 1\n    if frontDist > OPEN: return 0\n    if leftDist > OPEN: return -1\n    return 2\n\ndef rotate_to(offset):\n    # rotate robot based on chosen offset\n    if offset == 0:\n        return\n    if offset == 1:\n        turnR()\n    elif offset == -1:\n        turnL()\n    else:\n        turn180()\n\ndef drive_step_and_map(prevk):\n    # drive one tile forward and record it in the graph\n    global moved_steps\n    drivetrain.drive_for(FORWARD, STEP, MM)\n    moved_steps += 1\n    nk = curkey()\n    add_edge(prevk, nk)\n    route.append(nk)\n    return nk\n\ndef want_heading_from_delta(dx, dy):\n    # convert coordinate movement into heading value\n    if abs(dx) > abs(dy):\n        return 1 if dx > 0 else 3\n    return 0 if dy > 0 else 2\n\ndef bfs_path(start, goal):\n    # BFS shortest path search through mapped maze\n    if start == goal:\n        return [start]\n    if start not in edges or goal not in edges:\n        return []\n    q = [start]\n    prev = {start: None}\n    qi = 0\n    while qi < len(q):\n        u = q[qi]\n        qi += 1\n        if u == goal:\n            break\n        for v in edges.get(u, []):\n            if v not in prev:\n                prev[v] = u\n                q.append(v)\n    if goal not in prev:\n        return []\n    out = []\n    cur = goal\n    while cur is not None:\n        out.append(cur)\n        cur = prev[cur]\n    out.reverse()\n    return out\n\ndef follow_keys(path, stop_on_red):\n    # follow a shortest path node-by-node\n    global heading\n    if len(path) < 2:\n        return\n    for i in range(1, len(path)):\n        if stop_on_red and down_eye.detect(RED):\n            return\n        a = curkey()\n        ax, ay = key_xy(a)\n        bx, by = key_xy(path[i])\n        dx = bx - ax\n        dy = by - ay\n        want = want_heading_from_delta(dx, dy)\n        while heading != want:\n            turnR()\n        if front_distance.get_distance(MM) < OPEN:\n            return\n        drivetrain.drive_for(FORWARD, STEP, MM)\n        if stop_on_red and down_eye.detect(RED):\n            return\n\ndef reverse_route_to_start(startk):\n    # fallback: retrace the exact recorded route back home\n    global heading\n    i = len(route) - 1\n    while i >= 0:\n        if curkey() == startk:\n            return\n        tgt = route[i]\n        if tgt == curkey():\n            i -= 1\n            continue\n        ax, ay = key_xy(curkey())\n        bx, by = key_xy(tgt)\n        dx = bx - ax\n        dy = by - ay\n        want = want_heading_from_delta(dx, dy)\n        while heading != want:\n            turnR()\n        if front_distance.get_distance(MM) < OPEN:\n            return\n        drivetrain.drive_for(FORWARD, STEP, MM)\n        i -= 1\n\ndef when_started1():\n    # main program: reach finish, return home, then fastest route back\n    global heading, moved_steps, edges, route, finishk\n\n    pen.set_pen_color(BLUE)\n    pen.move(DOWN)\n\n    drivetrain.set_drive_velocity(180, PERCENT)\n    drivetrain.set_turn_velocity(180, PERCENT)\n\n    heading = 0\n    moved_steps = 0\n    edges = {}\n    route = []\n    finishk = None\n\n    startk = curkey()\n    route.append(startk)\n\n    cur = startk\n\n    while True:\n        # map maze until finish is found\n        if down_eye.detect(RED) and moved_steps > 2:\n            finishk = curkey()\n            break\n        d = step_dir_pref()\n        rotate_to(d)\n        cur = drive_step_and_map(cur)\n\n    # turn around after finish and move forward one tile\n    turn180()\n    prevk = curkey()\n    drivetrain.drive_for(FORWARD, STEP, MM)\n    afterk = curkey()\n    add_edge(prevk, afterk)\n    route.append(afterk)\n\n    # return home using shortest path\n    path_home = bfs_path(afterk, startk)\n    if len(path_home) >= 2:\n        follow_keys(path_home, False)\n    else:\n        reverse_route_to_start(startk)\n\n    # switch pen to green for fastest route run\n    pen.set_pen_color(GREEN)\n\n    # fastest route from start back to finish\n    path_fast = bfs_path(startk, finishk)\n    follow_keys(path_fast, True)\n\n    drivetrain.stop()\n\nvr_thread(when_started1)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.63.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"playground":"DynamicWallMaze","robotModel":"vr"}